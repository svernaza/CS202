{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red53\green53\blue53;}
{\*\expandedcolortbl;;\cssrgb\c27059\c27059\c27059;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs24 \cf2 Sam Vernaza\
CS202\
Project X Writeup\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf2 \
\pard\pardeftab560\slleading20\partightenfactor0
\cf2 The overlying purpose of this program is to experiment with the use of Smart Pointers. Smart pointers are a useful tool for referencing many different pointer values to the same memory address. The pointers are assignable to each other and primarily advantage by referencing one common destructor. The program\'92s purpose was to attempt to create a simulation class that handles the complexity of using smart pointers by ensuring that deletion and allocation of dynamic memory is well maintained and properly managed during its creation. This program has several functions that help aid this process. The larger overlying purpose is to have a many overloaded operators that handle what to do when a dynamic reference pointer references the same address in memory by an object. This program is responsible for the creation of objects that will work with the same memory indexes and thus it needs a safe way of allocating and tracking the memory deallocations before they happen. This program does this as the following. The default constructor is in charge of allocating the m_ptr to contain a new DataType value and a newly allocated size_t dynamic value in memory. It also releases a prompt demonstrating that this was successful. The smart pointer is then used in the ProjX.cpp to reference through indirection the SetIntVal and SetDoubleVal functions found in the DataType class, demonstrating that this pointer is able to access, though belonging to another class is able to reference methods from another class because of it\'92s overloaded indirection operator that allows it to do so by returning object of type DataType. We then see  a similar sequence of the program happening, but this time the creation of a new SmartPtr object is done by the copy constructor by way of overload assignment operator which handles assignment between two SmartPtr types and returns a reference to the object that invokes. That is SmartPtr sp2 = sp1 equivalent to saying SmartPtr (sp2.operator=(sp1)), thus invoking the copy constructor by using the assignment operator. The new object is created and thus allows us to access, again, the SetIntValue and the SetDoubleValue  found in the DataType class\'92 methods. Upon examination of the values here by dereferencing the values, we can see that the values of both the sp1 and sp2 pointers are referring to the same locations in memory. Additionally, while this has happened the m_refcount member has been updated to show that it\'92s count has increased. Finally, the program uses a default constructor initialization to allocate a new object with its own m_refcount of 1. then the assignment operator that is overloaded copies the value of sp1 into the previously created object (sp3), erasing its contents and now pointing the object to the same memory location as sp1. Upon dereferencing all 3 of these pointers, we see that they all point to the same location in memory and their values are all the same, that is both the m_ptr value and the m_refcount are valued as the same values. The program then demonstrates its ability to handle NULL pointers that are passed to smart pointers. The overlying goal of such a task is that it demonstrates that the program won\'92t throw errors because it knows the data that it is working with, even in the NULL case. Because of this the program doesn\'92t risk seg faulting and unnecessary memory leaks. The program creates object that still point to NULL memory and with a  m_refcount of 0 to symbolize that no dynamic pointers have been created that require deallocation. These NULL pointers act exactly the same way as the previous explanation mentioned. The program then is supposed to free all of the memory allocated, but in reverse order. It deallocated in LIFO order (Last In First Out). My program runs fairly well, but given more time I would like to have been able to understand why my program only deallocated the 3 newly created NULL values. I\'92ve tried tracing the bug and I just can\'92t find where the error is. If it was possible to have more time, this is what I would fix!}