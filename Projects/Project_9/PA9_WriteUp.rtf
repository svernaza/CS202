{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red53\green53\blue53;}
{\*\expandedcolortbl;;\cssrgb\c27059\c27059\c27059;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs24 \cf2 Sam Vernaza\
CS202\
Project 9 \
Write up\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf2 \
\pard\pardeftab560\slleading20\partightenfactor0
\cf2 The purpose of this program is to create two implementations of the queue ADT, implemented as both an Array queue and a Linked List queue. For starters, like program 8, we have been given the DataType header file and implementation file to work with. These files have been altered a bit by me from my last project and I enjoy keeping my implementations in them to deal with special circumstances I keep coming across. I\'92ve included an overloaded * operator for multiplication between constants and DataType objects. The major goals we were supposed to accomplish in this project are  to create a node based queue, array based queue and create our own test driver function. \
\
First, let\'92s discuss the first Node queue, as that\'92s the order of my project. The NodeQueue is the class we were required to implement it has a front pointer that indicates the start of a queue, a rear pointer to indicate where the end of the queue is, and each container is a collection of linked nodes. The NodeQueue relies on the Node class and is a friend to it. The main objective for this Node class is to serve as a container for the node object\'92s elements. The elements inside of the Node class are a DataType object and a recursive pointer of type Node to the next pointer of an object. This next pointer serves as a pointer to the next node that should occur in this queue. If there isn\'92t a queue then the node\'92s next pointer is initialized to NULL and marks the end of a queue. The constructors of the Node class take care of the creation of the node and automatically take care of the next pointer. They take care of it in multiple ways. There is a default constructor, parameterized constructor, and copy constructor. I won\'92t elaborate on the details of them as they are similar to all other implementations and will be considered simple from here on in my projects. The Node class also has three other useful functions, they are the GetData() which has both a const and a non-const version. Another implemented function I created was the SetData function. This simply sets data of a data type of a current DataType object after it has been created. It allows me to change the data as I like so that I can test different values of for searching a queue later. It\'92s a bonus function and not required. GetNext() is another function that I implemented to simply return the next pointer of a queue and is used lightly throughout the project. Again, it\'92s a bonus implementation and is designed to serve features in my driver file. \
\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf2 NodeQueue has three default constructors: default, parameterized, copy. The default constructor is called and set front to NULL and back to the front\'92s value. The parameterized constructor when called takes in a count and a DataType object. It checks that the count is valid, invokes a queue of new nodes that are of size Count and initializes each m_data member to be the value passed into the constructor. Copy constructor, takes a reference to the first node of a queue and then copies each value into its own LL. It utilizes increased performance assignment, considers three cases of assignment no queue, one item, more than one item. It assigns value by either direct assignment or traversal. The destructor will delete an entire queue if it exists. A message displays how many nodes were deleted. The overloaded assignment operator checks if the same assignment is happening. If not, then the assignment takes place and copies over the entire queue to another after it first removes any queue that already existed. m_front is then assigned the value of rhs, back is carried as the cases are met. Again this uses increased performance assignment, considers three cases of assignment no queue, one item, more than one item. The function first, returns a pointer to the first node of a queue if it exists, else NULL is returned. The function back, returns the back Node in the queue by traversal. The push() inserts a node into the previous position of front. It will use a temp pointer if a list exists and will assign a new node to the front of the list. Otherwise this is a new queue and it will assign a new node where both front and back point to it. The pop method considers the case when there is only one item in the queue, no items in the queue, and an entire list. If there is only one item in the queue, that node is delete and m_front is set to NULL as well as m_back. Other wise it will delete the node object and reconnect the queue as needed by isolating the front most node, moving the front to the next node in the list and deleting the isolated variable. Size(), returns the size of the current queue by traversing through it. Empty(), verifies that a queue is empty or isn\'92t. Clear() delete the contents of an entire queue. At the end of the deletion, m_front is NULL. Finally, the operator<< is overloaded to display an entire queue and will display all values by calling the serialize method. It takes in an std::ostream object and a const NodeQueue object that is the queue we will display, it calls the serialize method and returns the stream os object to the calling routine. The documentation for my driver file is very thorough and really doesn\'92t need to be explained, everything is explained for you, you\'92re welcome\'85I worked my butt off on that file.\
\
\pard\pardeftab560\slleading20\partightenfactor0
\cf2 ArrayQueue has three constructors as per usual; default constructor, parameterized constructor, and a copy constructor. These act as follows. The default constructor simply initializes values to zero and front and back to -1. The parameterized constructor takes in a count and DataType value. Creates an array of size count and initializes every member of the m_array to the DataType& value. The copy constructor takes in a constant value of one DataType object and allocates memory of the same size to this objects m_size member. Once the memory is allocated it copies all the values of the other array into this array. This constructor is special because I wanted to add variance to the values of the program so each creation of a new object is multiplied by an incrementing value of i in its implementation, you will see a loop in my driver function that does this (you\'92ll be prompted). This will have the effect of having larger values rapidly. You can always switch this value if needed. The destructor   deallocates the memory of an Arrayqueue object. No independent deallocation is required for each element since we are working with the int and double values stored within the index and can just let them rest as garbage. It also wasn\'92t necessary to create a destructor because the system could have easily handled one. The operator= is overloaded and will assign array index values to each other. This functionality is necessary because we are working with DataType objects and it\'92s important to realize we we\'92re working with a data type that needs to be defined in terms of the functionality of the assignment operator and that\'92s what this function does. It returns a pointer to the this function. First() returns the first occurrence of a value in the array by using the value in front to return the value stored at the numerical value of the array at index front. If there is an occurrence the address of that index is returned. Back() has the same functionality returns the value stored at the array index of value back. There are const and non-const versions with output statements to indicate when one is getting called versus the other one. I\'92ve also made one of the objects in the driver file const to invoke the const version of both back and front. The size() function simply returns the size of the array by returning m_size. The clear() function is used within the program and is primarily used in functions. the push function checks if the array queue is full and if so displays an error message and exits. If it\'92s empty, then the back and front are updated to zero and the size is incremented to one. If there is an existing list, then the backs value is incremented and we use this new value of back to dereference the array at this value for assignment of the DataType value passed into it. Pop() checks if the array queue is empty and if so, exits the function. If the back and the front are the same then we know we\'92ve reached the end of the queue and the size is assigned a value of zero, back and front are set to -1 to signal an empty queue exists. full() returns the boolean value of comparing the size and the ARRAY_MAX. Finally to display this the program calls the serialize method by invoking the overloaded insertion operator. Serialize displays the entire contents of the array by starting at the front of the array, using its value and traversing through the entire array until the back is reached. If there is nothing to display an empty array message is displayed. You\'92ll see it throughout the program being used, like in the destructor and in another function. Most of the features and functionality of the program are labeled and clearly identified. Be sure to look for things that can be uncommented to test other functionalities I\'92ve created for you to test the functionality of my functions and program. If given more time I would like to do this project dynamically to practice the use of new. I would also try this as a 2d array, but that\'92s more of a data structures class concept. Project was interesting.\
}