{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red53\green53\blue53;}
{\*\expandedcolortbl;;\cssrgb\c27059\c27059\c27059;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab560
\pard\pardeftab560\slleading20\partightenfactor0

\f0\fs24 \cf2 Sam Vernaza\
CS202\
Project 10\
Write up\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf2 \
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf2 The purpose of this program is to create two implementations of the stack ADT, implemented as both an Array stack and a Linked List stack. For starters, like program 9, we have been given the DataType header file and implementation file to work with. These files have been altered a bit by me from my last project and I enjoy keeping my implementations in them to deal with special circumstances I keep coming across. I\'92ve included an overloaded * operator for multiplication between constants and DataType objects. The major goals we were supposed to accomplish in this project are to create a node based stack, array based stack and create our own test driver function. Additionally, our goal was to template the classes so that they weren\'92t limited to just a DataType object. We can now use any data type for our class, as long as it makes sense with the storage of data.\
\
First, let\'92s discuss the first Node stack, as that\'92s the order of my project. The templated Nodestack is the class we were required to implement it has a top pointer that indicates the last item of the stack, each container is a collection of linked nodes. The Nodestack relies on the Node class and is a friend to it. The main objective for this Node class is to serve as a container for the node object\'92s elements. The elements inside of the Node class are templated to whatever type invokes the class and a recursive pointer of type Node type passed to the next pointer of an object. This next pointer serves as a pointer to the next node that should occur in this stack. If there isn\'92t a stack then the node\'92s next pointer is initialized to NULL and marks the end of a stack. The constructors of the Node class take care of the creation of the node and automatically take care of the next pointer. They take care of it in multiple ways. There is a default constructor, parameterized constructor, and copy constructor. I won\'92t elaborate on the details of them as they are similar to all other implementations and will be considered simple from here on in my projects. The Node class also has three other useful functions, they are the GetData() which has both a const and a non-const version. Another implemented function I created was the SetData function. This simply sets data of a data type of a current DataType object after it has been created. It allows me to change the data as I like so that I can test different values of for searching a stack later. It\'92s a bonus function and not required. GetNext() is another function that I implemented to simply return the next pointer of a stack and is used lightly throughout the project. Again, it\'92s a bonus implementation and is designed to serve features in my driver file. \
\
Nodestack has three default constructors: default, parameterized, copy. The default constructor is called and set top to NULL. The parameterized constructor when called takes in a count and an initialized type object. It checks that the count is valid, invokes a stack of new nodes that are of size Count and initializes each m_data member to be the value passed into the constructor. Copy constructor, takes a reference to the first node of a stack and then copies each value into its own LL. It utilizes increased performance assignment, considers three cases of assignment no stack, one item, more than one item. It assigns value by either direct assignment or traversal. The destructor will delete an entire stack if it exists. A message displays how many nodes were deleted. The overloaded assignment operator checks if the same assignment is happening. If not, then the assignment takes place and copies over the entire stack to another after it first removes any stack that already existed. m_top is then assigned the value of rhs, back is carried as the cases are met. Again this uses increased performance assignment, considers three cases of assignment no stack, one item, more than one item. The function top, returns a pointer to the top node of a stack if it exists, else NULL is returned. The push() inserts a node into the previous position of top, this pushed value is the new top. It will use a temp pointer if a list exists and will assign a new node to the top of the list. Otherwise this is a new stack and it will assign a new node where both top and back point to it. The pop method considers the case when there is only one item in the stack, no items in the stack, and an entire list. If there is only one item in the stack, that node is delete and m_top is set to NULL as well as m_back. Other wise it will delete the node object and reconnect the stack as needed by isolating the top most node, moving the top to the next node in the list and deleting the isolated node. Size(), returns the size of the current stack by traversing through it. Empty(), verifies that a stack is empty or isn\'92t. Clear() delete the contents of an entire stack. At the end of the deletion, m_top is NULL. Finally, the operator<< is overloaded to display an entire stack and will display all values by calling the serialize method. It takes in an std::ostream object and a const Nodestack object that is the stack we will display, it calls the serialize method and returns the stream os object to the calling routine. The documentation for my driver file is very thorough and really doesn\'92t need to be explained, everything is explained for you.\
\
The templated Arraystack has three constructors as per usual; default constructor, parameterized constructor, and a copy constructor. These act as follows. The default constructor simply initializes top to zero. The parameterized constructor takes in a count and templated type  value. Creates an array of size count and initializes every member of the m_array to the type& value. The copy constructor takes in a constant value of one passed type object and assigns this value. It copies all the values of the other array into this array. This constructor is special because I wanted to add variance to the values of the program so each creation of a new object is multiplied by an incrementing value of i in its implementation, you will see a loop in my driver function that does this (you\'92ll be prompted). This will have the effect of having larger values rapidly. You can always switch this value if needed. The destructor deletes the contents of the Arraystack object, this is unnecessary because the ArrayStack m_container is a static array that the compiler could have taken care of. No independent deallocation is required for each element since we are working with the int and double values stored within the index and can just let them rest as garbage. It also wasn\'92t necessary to create a destructor because the system could have easily handled one. The operator= is overloaded and will assign array index values to each other. This functionality is necessary because we are working with some type objects and it\'92s important to realize we we\'92re working with a data type that needs to be defined in terms of the functionality of the assignment operator and that\'92s what this function does. It returns a pointer to the this function. top() returns the first occurrence of a value in the array by using the value in top to return the value stored at the numerical value of the array at index top. If there is an occurrence the address of that index is returned. There are const and non-const versions with output statements to indicate when one is getting called versus the other one. I\'92ve also made one of the objects in the driver file const to invoke the const version of top. The size() function simply returns the size of the array by returning m_top, this will always be one less than the entire total because we are starting at a zero index. The clear() function is used within the program and is primarily used in functions. the push function checks if the array stack is full and if so displays an error message and exits. If it\'92s empty, then the top are updated to zero and the size is incremented to one. If there is an existing list, then the tops value is incremented and we use this new value of top to dereference the array at this value for assignment of the value passed into it. Pop() checks if the array stack is empty and if so, exits the function. If the top is zero then we know we\'92ve reached the end of the stack. full() returns the boolean value of comparing the size and the MAX_STACKSIZE. Finally to display this the program calls the serialize method by invoking the overloaded insertion operator. Serialize displays the entire contents of the array by starting at the top of the array, using its value and traversing through the entire array until the back is reached. If there is nothing to display an empty array message is displayed. You\'92ll see it throughout the program being used, like in the destructor and in another function. Most of the features and functionality of the program are labeled and clearly identified. Be sure to look for things that can be uncommented to test other functionalities I\'92ve created for you to test the functionality of my functions and program.\
\
If given more time I would like to do this project I would have liked to have had office hours to clarify some points about templates that tripped me up at first. I was getting some very strange error messages at first, but I eventually figured them out and realized where I was making my errors with return types and that changed my program\'92s success. I ended up finishing this project learning a lot about the power of templates. I was really happy to see the outcome of my project when it compiled and I was able to create a class that worked well with any datatype I wanted or created.\
}