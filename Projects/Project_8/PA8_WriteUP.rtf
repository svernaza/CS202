{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww7460\viewh16000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Samuel Vernaza\
CS202\
Project 8 Write_up\
\
For project number 8 we had to serve three purposes. They are create a node based list, array based list and a create our own test driver function. First let\'92s discuss the first Node List, as that\'92s the order of my project. The NodeList is the class we were required to implement it has a head pointer that indicates the start of a list, whose container is a collection of linked nodes. The NodeList relies on the Node class and is a friend to it. The main objective for this Node class is to serve as a container for the node object\'92s elements. The elements inside of the Node class are a DataType object and a recursive pointer of type Node to the next pointer of an object. This next pointer serves as a pointer to the next node that should occur in this list. If there isn\'92t a list then the node\'92s next pointer is initialized to NULL and marks the end of a list. The constructors of the Node class take care of the creation of the node and automatically take care of the next pointer. They take care of it in multiple ways. There is a default constructor, parameterized constructor, and copy constructor. I won\'92t elaborate on the details of them as they are similar to all other implementations and will be considered simple from here on in my projects. The Node class also has three other useful functions, they are the GetData() which has both a const and a non-const version. Another implemented function I created was the SetData function. This simply sets data of a data type of a current DataType object after it has been created. It allows me to change the data as I like so that I can test different values of for searching a list later. It\'92s a bonus function and not required. GetNext() is another function that I implemented to simply return the next pointer of a list and is used lightly throughout the project. Again, it\'92s a bonus implementation and is designed to serve features in my driver file. \
\
Now back to NodeList has three default constructors: default, parameterized, copy. The default constructor is called and set head to NULL. The parameterized constructor when called takes in a count and a DataType object. It checks that the count is valid, invokes a list of new nodes that are of size Count and initializes each m_data member to be the value passed into the constructor. Copy constructor, takes a pointer to the first node of a list and then copies each value into its own LL. It utilizes increased performance assignment, considers three cases of assignment no list, one item, more than one item. It assigns value by either direct assignment or traversal. The destructor will delete an entire list if it exists. A message displays how many nodes were deleted. The overloaded assignment operator Checks if the same assignment is happening. If not, then the assignment takes place and copies over the entire list to another after it first removes any list that already existed. m_head is then assigned the value of rhs. Again this uses increased performance assignment, considers three cases of assignment no list, one item, more than one item. The function first, returns a pointer to the first node of a list if it exists, else NULL is returned. The function last, returns the last Node in the list by traversal. The objective of Find is to search a NodeList for the occurrence of a match to the target if a match is found then it returns the current pointer to the and assigns that value to the calling client, it returns NULL otherwise. The InsertAfter(), searches a list for the target value, if the target value is found it will insert the new node after this value initialized to the value passed into it. InsertBefore(), will perform the same as the InsertFirst() function, but insert into the previous position. It will use a previous pointer and will assign the value prior to this address a new node, even if it\'92s the first. The only condition that it won\'92t assign for is if there isn\'92t a list that exists. Erase, searches the current list for an occurrence of a node that matches the target value. If there is a target match then the value is deleted. It considers the case when there is only one item in the list. If there is only one item in the list, that node is delete and m_head is set to NULL. Other wise it will delete the node object and reconnect the list as needed. There is an overloaded operator [] that will act similar to an array and will take in a position to search the list for. It doesn\'92t do any error checking and returns whatever node at the position given. Even if it doesn\'92t exist. Size(), returns the size of the current list by traversing through it. Empty(), verifies that a list is empty or isn\'92t. Clear() delete the contents of an entire list. At the end of the deletion, m_head is NULL. I wasn\'92t too sure about this implementation, so I mimicked the destructor. Finally, the operator<< is overloaded to display an entire list and will display all values. It takes in an std::ostream object and a const NodeList object that is the list we will display. The documentation for my driver file is very thorough and really doesn\'92t need to be explained, everything is explained for you, you\'92re welcome\'85I worked my butt off on that file.\
\
ArrayList has three constructors as per usual; default constructor, parameterized constructor, and a copy constructor. These act as follows. The default constructor simply initializes values to zero and NULL, that is m_size and m_array, respectively. The parameterized constructor takes in a count and DataType value. Creates an array of size count and initializes every member of the DataType to value. The copy constructor takes in a constant value of one array and allocates memory of the same size to this objects m_size member. Once the memory is allocated it copies all the values of the other array into this array. This constructor is special because I wanted to add variance to the values of the program so each creation of a new object is multiplied by an incrementing value of i in its implementation. This will have the effect of having larger values rapidly. You can always switch this value if needed. The destructor   deallocates the memory of an ArrayList object. No independent deallocation is required for each element since we are working with the int and double values stored within the index and can just let them rest as garbage. The operator= is overloaded and will assign array index values to each other. This functionality is necessary because we are working with DataType objects and it\'92s important to realize we we\'92re working with a data type that needs to be defined in terms of the functionality of the assignment operator and that\'92s what this function does. It returns a pointer to the this function. First() returns the first occurrence of a value in the array by traversing through the list and using the empty() function to verify that the contents are valid. If there is an occurrence the address of that index is returned. If there isn\'92t a value found then the NULL pointer is returned. Last has the same functionality except that it searches from the rear end of the list and decrements until a value is found. It returns a value if found and NULL otherwise, this also uses the empty() function. Find(), takes in a target DataType target value for comparison of values within the current array object. The value is compared through each element of the List while we traverse through the array. If a match is found and it's not the first value, then the value of previous is set to the previous array index and the value of the matched data is returned to the calling routine that invoked it. This doesn't invoke the start functionality. Another important note is that this whole time the reason why I can access index values is because I\'92ve overloaded the operator[] to return values of type DataType at a given position index. This is really important to the functionality of the program and wouldn\'92t have happened if we didn\'92t do this. The size() function simply returns the size of the array by returning m_size. The clear() function is used within the program and is primarily used in functions. You\'92ll see it throughout the program being used, like in the destructor and in another function. There is no prompt in the program for it.}