Sam Vernaza
Write Up for CS202 Project 7

The overall purpose of this program was to learn and demonstrate proper memory allocation and dynamic programming techniques. This program proved to have an overall projected goal of working with classes while maintaining an involvement with new concepts such as, ironically, new and delete.The major obstacle of this project was to properly and sufficiently allocate memory for new dynamic character arrays. My program demonstrates multiple methods for allocation of new memory by the following. The program first has a default constructor for invocation that calls an internal private function called buffer_allocate(), which properly allocates the required size to store any dynamic character array. However, in the case of the dynamically allocated array, there isn't a sizable value to allocate storage for and thus, the dynamic array is initialized to a single character with the first index value set to NULL ('\0'). The second useful constructor is the parameterized constructor which can be passed a sizable value from the invoking object. In the parameterized version of the function the length of the passed in string is taken into account and a dynamic array is created that meets the criteria for storing an exact replica of the value passed in. Once the allocated memory is created it will do an internal string copy and copy the contents of the string passed in. This value serves as the newly instantiated object's value and now resides in the contents of the object with the m_size object member properly initialized to this size. Another method of invocation is the use of the copy constructor, which is able to take a MyString object passed into it in order to set the members of the invoking object to match the contents of the copied object being passed to it. In addition to the multiple constructor variations, we have a single destructor that simply deallocates the memory created for the m_buffer pointer and sets the size to zero, updating the object to its most valid representation. The size function is responsible for returning the size of the container in bytes and the length function is responsible for returning the number of elements in the character array. C_str() is a function that will return a pointer to the m_buffer if it is currently allocated or will return a single character array initialized to NULL in the event that the m_buffer isn't initialized. MY program also includes multiple overloaded functions that compare the equality of the object passed to it, checking that the contents are equivalent. It's a very simple function that first does a string compare on the actual string values of the objects being compared and then taking the result returned by the strcmp() function compares the result returned with zero and returns the validity of the operation to the calling routine. The assignment operator first checks that a self assignment is attempted, if so it returns the current object's value back to the calling routine. If the object differs from the assignment operator, then the current objects values are cleared and a new m_buffer is allocated to make room for the passed object's data members. This is then copied to the current object's data members and the reference to the object is returned. The string concatenation will take two strings and append the value of the second one to the first as it. That is, it will return the value of the second strings to the first after a proper memory allocation has been made to ensure that the size of both the first string and the second will fit in a newly allocated string that contains both of them. The object will appear as is, meaning a space won't distinguish the two strings unless explicitly typed. Finally the two overloaded bracket operators allow for read/write privileges (non-const version) and read-only privileges (const version). This allows for reassignment from the calling routine and also ensures that elements of the object are kept in tact when not explicitly attempted to be altered or changed. The overloaded insertion operator will return a reference to the ostream object that called the overloaded function to display the contents of the MyString object passed to it. My design was simplistic and expressed readability, it really requires that the user of the program simply read what the function is supposed to do and invokes the operations accordingly. If I had more time I would like to understand the c_str() operator a bit more because I found its use confusing. I wasn't quite sure that the implementation I used was what the std::String library implementation would necessarily invoke, but I found that it's use was suited for my specific project. 
